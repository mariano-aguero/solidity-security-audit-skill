# Exploit Case Studies

Analysis of real-world exploits with vulnerable code, attack flow, and fixes.

---

## The DAO Hack (2016) - $60M

**Vulnerability**: Classic Reentrancy

### Vulnerable Code

```solidity
function withdraw(uint256 amount) external {
    require(balances[msg.sender] >= amount);

    // External call BEFORE state update
    (bool success,) = msg.sender.call{value: amount}("");
    require(success);

    // State update AFTER external call - vulnerable!
    balances[msg.sender] -= amount;
}
```

### Attack Flow

1. Attacker deposits ETH
2. Attacker calls `withdraw()`
3. Contract sends ETH to attacker
4. Attacker's `receive()` calls `withdraw()` again
5. Balance not yet updated, so check passes
6. Repeat until drained

### Fix

```solidity
function withdraw(uint256 amount) external nonReentrant {
    require(balances[msg.sender] >= amount);

    // State update BEFORE external call (CEI pattern)
    balances[msg.sender] -= amount;

    (bool success,) = msg.sender.call{value: amount}("");
    require(success);
}
```

### Lessons

- Always follow Checks-Effects-Interactions (CEI)
- Use reentrancy guards as defense in depth
- External calls are dangerous

---

## Beanstalk Governance Attack (2022) - $182M

**Vulnerability**: Flash Loan Governance

### Vulnerable Pattern

```solidity
// Voting power based on CURRENT balance
function getVotes(address account) public view returns (uint256) {
    return governanceToken.balanceOf(account); // Vulnerable!
}
```

### Attack Flow

1. Attacker creates malicious proposal
2. Flash borrows massive amount of governance tokens
3. Votes with flash-borrowed tokens (live balance)
4. Proposal passes quorum in single block
5. Executes proposal to drain treasury
6. Returns flash loan

### Fix

```solidity
// Use snapshot-based voting (ERC20Votes)
function getVotes(address account) public view returns (uint256) {
    return governanceToken.getPastVotes(account, proposalSnapshot);
}

// Add voting delay
function propose(...) external returns (uint256) {
    uint256 snapshot = block.number + votingDelay; // e.g., 1 day
    // ...
}
```

### Lessons

- Never use live balances for governance
- Use ERC20Votes with checkpoints
- Enforce voting delay between proposal and voting

---

## Euler Finance (2023) - $197M

**Vulnerability**: Donate + Liquidation Logic Error

### Vulnerable Pattern

```solidity
function donateToReserves(uint256 amount) external {
    // Attacker can donate to manipulate health factor
    reserves += amount;
    _burn(msg.sender, amount); // Reduces attacker's debt tokens
}

function liquidate(address violator) external {
    require(isLiquidatable(violator));
    // Liquidation based on manipulated reserves
}
```

### Attack Flow

1. Flash borrow large amount
2. Deposit as collateral
3. Borrow against collateral
4. Donate borrowed assets to reserves (reduces own debt)
5. Self-liquidate at profitable rate
6. Withdraw collateral at manipulated price
7. Repay flash loan, keep profit

### Fix

```solidity
function donateToReserves(uint256 amount) external {
    // Don't allow donation to affect liquidation math
    // Or: restrict donation to authorized roles
    require(msg.sender == governance, "Unauthorized");
    reserves += amount;
}
```

### Lessons

- Audit interaction between all functions
- Donation functions can manipulate accounting
- Test with economic attack simulations

---

## Curve Read-Only Reentrancy (2023) - $70M+

**Vulnerability**: Read-Only Reentrancy

### Vulnerable Pattern

```solidity
// Curve Pool
function remove_liquidity() external {
    // Update internal state
    // Send ETH (triggers callback)
    // Finalize state
}

function get_virtual_price() external view returns (uint256) {
    // Returns price based on CURRENT state
    // During remove_liquidity, state is inconsistent
}

// Victim Protocol
function getCollateralValue() external view returns (uint256) {
    uint256 price = curvePool.get_virtual_price(); // Reads stale price!
    return lpBalance * price;
}
```

### Attack Flow

1. Attacker calls `remove_liquidity` on Curve
2. During callback (mid-execution), state is inconsistent
3. Attacker calls victim protocol that reads `get_virtual_price()`
4. Victim gets artificially low price
5. Attacker exploits mispriced collateral
6. Curve execution completes

### Fix

```solidity
// Option 1: Reentrancy lock on view functions
function get_virtual_price() external view nonReentrant returns (uint256) {
    // ...
}

// Option 2: Check reentrancy state
function getCollateralValue() external view returns (uint256) {
    require(!curvePool.isLocked(), "Reentrancy");
    uint256 price = curvePool.get_virtual_price();
    return lpBalance * price;
}
```

### Lessons

- View functions can return stale data during reentrancy
- Don't trust external protocol's view functions unconditionally
- Consider reentrancy guards even on view functions

---

## Nomad Bridge (2022) - $190M

**Vulnerability**: Failed Message Validation

### Vulnerable Pattern

```solidity
function process(bytes memory message) external {
    bytes32 messageHash = keccak256(message);

    // Vulnerable: accepted zero/uninitialized as valid
    require(messages[messageHash] == VALID, "Invalid");

    // Process message...
}

// After upgrade, messages mapping returned 0 for unknown hashes
// And 0 was accidentally set as VALID constant
```

### Attack Flow

1. Bridge upgrade introduced bug in validation
2. Any message hash returned "valid" (zero == VALID)
3. Attacker crafts arbitrary message
4. Bridge accepts and processes fake message
5. Attacker withdraws tokens they never deposited
6. Others copy attack (copy-paste exploit)

### Fix

```solidity
bytes32 constant VALID = keccak256("VALID"); // Non-zero!
bytes32 constant INVALID = bytes32(0);

function process(bytes memory message) external {
    bytes32 messageHash = keccak256(message);
    require(messages[messageHash] == VALID, "Invalid");

    // Mark as processed
    messages[messageHash] = INVALID;

    // Process...
}
```

### Lessons

- Never use zero as valid state
- Test upgrade paths thoroughly
- Merkle proofs > simple hash mapping

---

## Wormhole (2022) - $325M

**Vulnerability**: Signature Verification Bypass

### Vulnerable Pattern

```solidity
// Deprecated function still accessible
function verify_signatures(
    bytes memory signatures,
    bytes32 hash
) external view returns (bool) {
    // Vulnerable implementation
}

// New function with proper checks not used in all paths
```

### Attack Flow

1. Attacker found deprecated verification function
2. Crafted message that passed weak verification
3. Bridge accepted fake "deposit" message from Solana
4. Minted 120,000 wETH on Ethereum
5. Bridged out to other chains

### Lessons

- Remove deprecated code completely
- Audit all code paths, not just happy path
- Defense in depth for bridge validators

---

## Compound Governance Bug (2021) - $80M

**Vulnerability**: Logic Error in Distribution

### Vulnerable Pattern

```solidity
function claimComp(address holder) external {
    // Bug: wrong comparison operator
    if (compAccrued[holder] > compBalance) {
        // Should be: compAccrued[holder] <= compBalance
        compAccrued[holder] = compBalance;
    }

    // Transferred more than intended
    doTransferOut(holder, compAccrued[holder]);
}
```

### Impact

- Users received 100x intended rewards
- No theft - just faulty distribution
- Required governance proposal to fix

### Lessons

- Test edge cases in reward distribution
- Invariant: totalDistributed <= totalAllocated
- Timelocks allow reaction time (but also delay fixes)

---

## Summary: Common Patterns

| Attack Type | Root Cause | Prevention |
|-------------|------------|------------|
| Reentrancy | State update after external call | CEI pattern, ReentrancyGuard |
| Flash Loan Governance | Live balance voting | ERC20Votes snapshots |
| Oracle Manipulation | Spot price dependency | TWAP, Chainlink |
| Read-Only Reentrancy | Stale view during callback | Lock view functions |
| Bridge Validation | Weak message verification | Merkle proofs, multi-sig |
| Donation Attack | Balance used for accounting | Internal accounting |
| Logic Errors | Wrong operators, edge cases | Extensive testing, invariants |
