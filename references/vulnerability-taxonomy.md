# Vulnerability Taxonomy for Solidity Smart Contracts

Comprehensive classification of smart contract vulnerabilities mapped to
SWC Registry (EIP-1470), EEA EthTrust Security Levels, and SCSVS.

See `industry-standards.md` for full SWC reference table and severity standards.

---

## Table of Contents

1. [Reentrancy Vulnerabilities](#1-reentrancy-vulnerabilities)
2. [Access Control Flaws](#2-access-control-flaws)
3. [Arithmetic Issues](#3-arithmetic-issues)
4. [Oracle & Price Manipulation](#4-oracle--price-manipulation)
5. [Flash Loan Attack Vectors](#5-flash-loan-attack-vectors)
6. [Proxy & Upgradeability Issues](#6-proxy--upgradeability-issues)
7. [External Call Hazards](#7-external-call-hazards)
8. [Denial of Service](#8-denial-of-service)
9. [Front-Running & MEV](#9-front-running--mev)
10. [Signature & Cryptographic Issues](#10-signature--cryptographic-issues)
11. [Token Standard Pitfalls](#11-token-standard-pitfalls)
12. [Logic & Business Errors](#12-logic--business-errors)
13. [Gas & Optimization Issues](#13-gas--optimization-issues)
14. [Solidity-Specific Pitfalls](#14-solidity-specific-pitfalls)
15. [Governance Vulnerabilities](#15-governance-vulnerabilities)
16. [Cross-Chain & Bridge Risks](#16-cross-chain--bridge-risks)
17. [ERC-7702 Account Vulnerabilities](#17-erc-7702-account-vulnerabilities)
18. [Uniswap V4 Hook Vulnerabilities](#18-uniswap-v4-hook-vulnerabilities)
19. [Transient Storage Specific Issues](#19-transient-storage-specific-issues)

---

## 1. Reentrancy Vulnerabilities

**SWC-107** | **EthTrust: [S] Level 1** | **Impact: Critical**

Reentrancy occurs when a contract calls an external address before completing
its own state changes, allowing the called contract to re-enter and repeat
actions (like withdrawals) before the state reflects the first action.

### 1.1 Classic Reentrancy (Single-Function)

The original pattern from The DAO hack (2016, $60M loss). A function sends
ETH via `call` before updating internal balances.

**Vulnerable pattern:**
```solidity
function withdraw() external {
    uint256 amount = balances[msg.sender];
    (bool success, ) = msg.sender.call{value: amount}("");
    require(success);
    balances[msg.sender] = 0; // State update AFTER external call
}
```

**Secure pattern (CEI):**
```solidity
function withdraw() external nonReentrant {
    uint256 amount = balances[msg.sender];
    balances[msg.sender] = 0; // State update BEFORE external call
    (bool success, ) = msg.sender.call{value: amount}("");
    require(success);
}
```

### 1.2 Cross-Function Reentrancy

Attacker re-enters through a DIFFERENT function that shares state with the
vulnerable function.

**Detection**: Look for multiple functions that read/write the same state
variable AND at least one of them makes an external call.

### 1.3 Cross-Contract Reentrancy

The re-entry happens on a different contract that shares state or has trust
relationships with the vulnerable contract.

**Detection**: Map all inter-contract calls and shared state. Particularly
common in protocol systems with multiple interacting contracts.

### 1.4 Read-Only Reentrancy

An attacker re-enters a `view` function during state changes, getting a stale
(inconsistent) view of the contract state. This can affect other protocols
that read from the vulnerable contract.

**Real-world example**: Curve pool read-only reentrancy (2023) exploited by
calling `get_virtual_price()` during a state-changing operation.

**Detection**: Check if any `view` functions are called by external contracts
during state transitions. Particularly dangerous in composable DeFi.

### 1.5 Transient Storage Reentrancy Lock (EIP-1153)

Solidity 0.8.24+ (Cancun upgrade) introduces transient storage via `tload`/`tstore`.
This provides a more gas-efficient reentrancy guard that automatically clears at
the end of each transaction.

```solidity
// Solidity 0.8.24+ with Cancun
contract ReentrancyGuardTransient {
    bytes32 constant REENTRANCY_GUARD_SLOT = keccak256("reentrancy.guard");

    modifier nonReentrant() {
        assembly {
            if tload(REENTRANCY_GUARD_SLOT) {
                mstore(0, 0x37ed32e8) // ReentrancyGuardReentrantCall()
                revert(0x1c, 0x04)
            }
            tstore(REENTRANCY_GUARD_SLOT, 1)
        }
        _;
        assembly {
            tstore(REENTRANCY_GUARD_SLOT, 0)
        }
    }
}
```

**Advantages over traditional ReentrancyGuard:**
- No persistent storage writes (saves ~5000 gas per call)
- Automatically clears at transaction end
- Same security guarantees

### Remediation

- Apply Checks-Effects-Interactions (CEI) pattern strictly
- Use OpenZeppelin `ReentrancyGuard` (`nonReentrant` modifier)
- For Solidity 0.8.24+: consider transient storage reentrancy locks
- For read-only reentrancy: use reentrancy locks on view functions or
  implement a global reentrancy guard across the protocol

---

## 2. Access Control Flaws

**SWC-100, SWC-106** | **EthTrust: [S] Level 1** | **Impact: Critical to High**

Access control vulnerabilities caused $953M in losses in 2024 alone,
making them the #1 vulnerability category by financial impact.

### 2.1 Missing Access Modifiers

Functions that should be restricted (admin operations, minting, pausing)
but lack `onlyOwner`, `onlyRole`, or custom modifiers.

**Detection**: List every function that modifies critical state. Verify
each has appropriate access restrictions.

### 2.2 Unprotected Initializers

In proxy patterns, the `initialize()` function replaces the constructor.
If it lacks proper access control or can be called multiple times, an
attacker can take ownership.

**Vulnerable:**
```solidity
function initialize(address _owner) public {
    owner = _owner;
}
```

**Secure:**
```solidity
function initialize(address _owner) public initializer {
    __Ownable_init(_owner);
}
```

### 2.3 tx.origin Authentication

Using `tx.origin` instead of `msg.sender` for authorization allows phishing
attacks where a user is tricked into calling a malicious contract.

**SWC-115**: Always use `msg.sender` for authentication.

### 2.4 Incorrect Role Hierarchy

Role-based systems where a lower-privileged role can grant itself higher
privileges, or where admin role transitions have no timelock.

### 2.5 Missing Two-Step Ownership Transfer

Single-step ownership transfer (e.g., `transferOwnership(newOwner)`) risks
permanent loss if sent to wrong address. Use OpenZeppelin's
`Ownable2Step` pattern.

```solidity
import {Ownable2Step, Ownable} from "@openzeppelin/contracts/access/Ownable2Step.sol";

contract Vault is Ownable2Step {
    constructor() Ownable(msg.sender) {}
}
// Transfer requires: 1. transferOwnership(newOwner) 2. newOwner.acceptOwnership()
```

### 2.6 Modern Access Control with AccessManager (OZ 5.x)

OpenZeppelin 5.x introduces `AccessManager` for centralized, granular access control
across multiple contracts.

```solidity
import {AccessManager} from "@openzeppelin/contracts/access/manager/AccessManager.sol";
import {AccessManaged} from "@openzeppelin/contracts/access/manager/AccessManaged.sol";

contract Treasury is AccessManaged {
    constructor(address manager) AccessManaged(manager) {}

    function withdraw(uint256 amount) external restricted {
        // Only callable by accounts with permission
    }
}

// Setup
AccessManager manager = new AccessManager(admin);
uint64 constant WITHDRAWER_ROLE = 1;
manager.grantRole(WITHDRAWER_ROLE, withdrawer, 0);

bytes4[] memory selectors = new bytes4[](1);
selectors[0] = Treasury.withdraw.selector;
manager.setTargetFunctionRole(address(treasury), selectors, WITHDRAWER_ROLE);
```

**Audit checks for AccessManager:**
- Verify role assignments are correct
- Check function-to-role mappings
- Ensure admin role transitions have appropriate delays

---

## 3. Arithmetic Issues

**SWC-101** | **EthTrust: [S] Level 1** | **Impact: High**

### 3.1 Integer Overflow/Underflow

Pre-Solidity 0.8.0: arithmetic wraps silently. Post-0.8.0: automatic
checks revert on overflow. BUT `unchecked` blocks bypass this protection.

**Detection**: Search for all `unchecked { }` blocks and verify every
arithmetic operation inside is intentionally unchecked with valid bounds.

### 3.2 Division Precision Loss

Solidity has no floating-point types. Division truncates toward zero.

```solidity
// BAD: precision loss
uint256 reward = totalRewards * userStake / totalStaked / PRECISION;

// BETTER: multiply before dividing
uint256 reward = (totalRewards * userStake * PRECISION) / totalStaked / PRECISION;
```

### 3.3 Rounding Direction Attacks

In DeFi protocols, rounding should always favor the protocol over the user
to prevent extraction of value through repeated small operations.

**Detection**: Check all division operations. Ensure rounding direction is
explicit and consistent. Use `mulDiv` with rounding direction parameter
(OpenZeppelin Math library).

---

## 4. Oracle & Price Manipulation

**Impact: Critical** | **Source: Cyfrin, Chainlink, OpenZeppelin research**

Oracle manipulation caused $380M+ in DeFi losses in 2024-2025.

### 4.1 Spot Price Dependency

Using current pool reserves or spot prices from a single DEX as the price
feed. Trivially manipulable with flash loans.

**Vulnerable:**
```solidity
function getPrice() internal view returns (uint256) {
    (uint112 reserve0, uint112 reserve1, ) = pair.getReserves();
    return reserve1 * 1e18 / reserve0;
}
```

**Secure:** Use Chainlink price feeds with freshness checks, or TWAP
(Time-Weighted Average Price) oracles with sufficient observation window.

### 4.2 Stale Price Data

Oracle prices that haven't been updated within acceptable timeframes.

**Detection**: Check for `updatedAt` validation in Chainlink integrations:
```solidity
(, int256 price, , uint256 updatedAt, ) = priceFeed.latestRoundData();
require(block.timestamp - updatedAt < MAX_STALENESS, "Stale price");
require(price > 0, "Invalid price");
```

### 4.3 Oracle Centralization

Single oracle source creates a single point of failure. Consider multiple
oracle sources with median or fallback patterns.

### 4.4 L2 Sequencer Dependencies

On L2s (Arbitrum, Optimism), check if the sequencer is up before relying
on oracle data. Stale prices during sequencer downtime have caused exploits.

---

## 5. Flash Loan Attack Vectors

**Impact: Critical** | **Source: Aave, dYdX, Euler incident analyses**

Flash loans allow borrowing unlimited assets within a single transaction
with zero collateral, enabling economic attacks.

### 5.1 Governance Flash Loan Attacks

Borrowing governance tokens to pass malicious proposals in a single block.

**Detection**: Check if governance power is based on current balance vs.
snapshot-based (ERC20Votes with checkpoints).

### 5.2 Price Manipulation via Flash Loans

Using flash-loaned tokens to manipulate AMM prices, then exploiting
protocols that rely on those prices.

### 5.3 Collateral Ratio Manipulation

Flash-borrowing to inflate collateral value, taking out under-collateralized
loans, then returning the flash loan.

### Remediation

- Use TWAP oracles with multi-block observation windows
- Implement per-block operation limits
- Require token snapshots for governance (not live balances)
- Add cooldown periods between deposit and borrow

---

## 6. Proxy & Upgradeability Issues

**SWC-112** | **Impact: Critical** | **Source: OpenZeppelin, Trail of Bits**

### 6.1 Storage Collision

Proxy and implementation contracts sharing the same storage slots. When
upgrading, new storage variables can overwrite existing data.

**Prevention**: Use EIP-7201 namespaced storage or OpenZeppelin's storage
gap pattern.

**ERC-7201 Namespaced Storage Pattern:**

```solidity
abstract contract VaultStorage {
    /// @custom:storage-location erc7201:vault.storage
    struct VaultStorageStruct {
        mapping(address => uint256) balances;
        uint256 totalSupply;
    }

    // keccak256(abi.encode(uint256(keccak256("vault.storage")) - 1)) & ~bytes32(uint256(0xff))
    bytes32 private constant VAULT_STORAGE_LOCATION =
        0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcd00;

    function _getVaultStorage() internal pure returns (VaultStorageStruct storage $) {
        assembly { $.slot := VAULT_STORAGE_LOCATION }
    }
}
```

**Audit checks:**
- Verify storage location hash is correctly computed
- Check that all state is accessed through the namespaced struct
- Ensure no direct storage variables outside the namespace

### 6.2 Uninitialized Implementation

The implementation contract behind a proxy can be initialized by an
attacker if `initialize()` wasn't called on the implementation itself.
This can lead to `selfdestruct` of the implementation.

**Prevention**: Call `_disableInitializers()` in the implementation constructor.

### 6.3 Function Selector Clashing

Proxy admin functions sharing selectors with implementation functions.
OpenZeppelin's TransparentUpgradeableProxy prevents this, but custom
proxies may not.

### 6.4 UUPS Missing Authorization

In UUPS proxies, the `_authorizeUpgrade` function on the implementation
must have proper access control. If missing, anyone can upgrade.

### 6.5 Storage Layout Changes on Upgrade

Adding, removing, or reordering storage variables between implementation
versions corrupts storage. Only append new variables at the end.

---

## 7. External Call Hazards

**SWC-104, SWC-107** | **Impact: High**

### 7.1 Unchecked Return Values

Low-level calls (`call`, `send`, `delegatecall`) return a boolean.
Failure to check can leave the contract in an inconsistent state.

**SWC-104**: Always check return values:
```solidity
(bool success, ) = recipient.call{value: amount}("");
require(success, "Transfer failed");
```

### 7.2 Delegatecall to Untrusted Contracts

`delegatecall` executes external code in the calling contract's context,
giving it full access to storage and funds.

**SWC-112**: Never `delegatecall` to user-controlled addresses.

### 7.3 Unsafe External Contract Interaction

Calling external contracts without verifying they implement expected
interfaces. Use interface checks or try-catch patterns.

### 7.4 Gas Griefing via Insufficient Gas

Forwarding insufficient gas to external calls can cause them to fail
silently, potentially leaving the calling contract in an invalid state.

---

## 8. Denial of Service

**SWC-113, SWC-128** | **Impact: High to Medium**

### 8.1 Unbounded Loops

Iterating over arrays that grow without bound can exceed block gas limits,
making functions permanently uncallable.

**Detection**: Check all `for` loops. If the array length is user-influenced
or grows over time, the function is vulnerable.

### 8.2 Unexpected Revert in Loops

A single revert in a batch operation (e.g., airdrop) blocks the entire
transaction.

**Prevention**: Use try-catch for external calls in loops, or implement
pull-based distribution patterns.

### 8.3 Block Gas Limit Manipulation

Functions that must process all pending items in one transaction risk
being permanently blocked if the queue grows too large.

### 8.4 Self-Destruct Forcing ETH

An attacker can force-send ETH to a contract via `selfdestruct`, breaking
invariants that depend on `address(this).balance`.

**Detection**: Check if any logic depends on exact ETH balance.

---

## 9. Front-Running & MEV

**SWC-114** | **Impact: High to Medium** | **Source: Flashbots research**

### 9.1 Transaction Ordering Dependence

Functions whose outcome depends on execution order in a block. Common
in DEX swaps, NFT mints, and liquidations.

### 9.2 Sandwich Attacks

MEV bots detect pending DEX swaps and place transactions before and after
to extract value from the user's slippage tolerance.

**Remediation**: Enforce minimum output amounts (`amountOutMin`), use
deadlines, consider private mempools (Flashbots Protect).

### 9.3 Commit-Reveal Weakness

If commit-reveal schemes don't include sufficient entropy or binding
commitments, they can be front-run.

### 9.4 ERC-4337 (Account Abstraction) MEV Risks

UserOperations in the mempool can be inspected and exploited similar to
traditional EOA transactions.

---

## 10. Signature & Cryptographic Issues

**SWC-117, SWC-121, SWC-122** | **Impact: High**

### 10.1 Signature Replay

Missing nonce or chain ID in signed messages allows replaying valid
signatures across transactions or chains.

**Prevention**: Include nonce, chain ID, contract address, and deadline
in all signed messages. Follow EIP-712 for typed structured data.

### 10.2 Signature Malleability

ECDSA signatures have two valid forms (s and n-s). Without normalization,
the same message can have two valid signatures.

**Prevention**: Use OpenZeppelin's ECDSA library which enforces low-s
values, or EIP-2098 compact signatures.

### 10.3 Missing Signer Validation

Not checking that `ecrecover` returns a valid, non-zero address, or not
verifying the recovered address against the expected signer.

### 10.4 EIP-712 Implementation Errors

Incorrectly computing domain separator or type hashes, making signatures
incompatible or vulnerable to cross-domain replay.

---

## 11. Token Standard Pitfalls

**Impact: Medium to High** | **Source: OpenZeppelin, Consensys Diligence**

### 11.1 ERC-20: Fee-on-Transfer and Rebasing Tokens

Some ERC-20 tokens deduct fees on transfer or rebase balances. Contracts
that assume `balanceOf` increases by exactly `amount` after `transferFrom`
will have accounting errors.

**Detection**: Check if the protocol measures received tokens via balance
difference:
```solidity
uint256 before = token.balanceOf(address(this));
token.transferFrom(msg.sender, address(this), amount);
uint256 received = token.balanceOf(address(this)) - before;
```

### 11.2 ERC-20: Missing Return Values

Some tokens (USDT, BNB) don't return `bool` from `transfer`/`approve`.
Use OpenZeppelin's `SafeERC20` (`safeTransfer`, `safeApprove`).

### 11.3 ERC-20: Approve Race Condition

Changing an allowance from N to M allows the spender to use N+M total.
Use `increaseAllowance`/`decreaseAllowance` or set to 0 first.

### 11.4 ERC-721: Safe Mint Reentrancy

`_safeMint` calls `onERC721Received` on the recipient, which can be a
contract that re-enters the minting function.

### 11.5 ERC-4626: Vault Inflation Attack

First depositor can manipulate share price by donating tokens directly
to the vault, making subsequent deposits receive fewer shares.

**Prevention**: Use virtual offset (OpenZeppelin) or require minimum
initial deposit.

---

## 12. Logic & Business Errors

**Impact: Varies** | **Identified primarily through manual review**

### 12.1 Incorrect State Machine Transitions

Contracts with multiple states (e.g., auction: open → closed → settled)
where invalid transitions are possible.

### 12.2 Off-by-One Errors

Boundary conditions in loops, time checks (`<=` vs `<`), array indexing.

### 12.3 Incorrect Fee/Reward Calculations

Accumulation errors in reward-per-share models, fee distribution with
precision loss, or incorrect compounding logic.

### 12.4 Missing Slippage Protection

Functions that swap or convert assets without enforcing minimum output
amounts or deadlines.

### 12.5 Inconsistent State After Partial Execution

Functions that modify multiple state variables but can revert midway,
leaving state partially updated (if using try-catch incorrectly).

---

## 13. Gas & Optimization Issues

**Impact: Low to Medium** | **Source: Foundry gas reports, Cyfrin**

### Gas Cost Reference

| Operation | Gas Cost |
|-----------|----------|
| SSTORE (0 → non-0) | 20,000 |
| SSTORE (non-0 → non-0) | 5,000 |
| SSTORE (non-0 → 0) | Refund 4,800 |
| SLOAD | 2,100 (cold) / 100 (warm) |
| CALL | 2,600 (cold) / 100 (warm) |
| Memory expansion | Quadratic |
| MLOAD/MSTORE | 3 |
| Deployment per byte | 200 |

### 13.1 Storage vs Memory vs Calldata

- Use `calldata` for read-only function parameters (cheapest)
- Use `memory` for local variables that need modification
- Minimize `storage` reads/writes (each SLOAD = 2100 gas cold)

```solidity
// BAD: Copies to memory (~3 gas per byte + memory expansion)
function bad(uint256[] memory data) external { }

// GOOD: Reads directly from calldata (~3 gas per element)
function good(uint256[] calldata data) external { }
```

### 13.2 Redundant State Reads

Reading the same storage variable multiple times. Cache in a local variable.

```solidity
// BAD: Multiple SLOADs (~2,100 each)
function bad() external view returns (uint256) {
    return balances[msg.sender] + balances[msg.sender] * rate / 100;
}

// GOOD: Single SLOAD
function good() external view returns (uint256) {
    uint256 balance = balances[msg.sender];
    return balance + balance * rate / 100;
}
```

### 13.3 Packed Storage

Smaller types (`uint128`, `uint96`, `bool`) can share a storage slot when
declared consecutively, saving gas on reads and writes.

```solidity
// BAD: 3 storage slots (60k gas to write all)
struct User {
    uint256 id;       // slot 0
    address wallet;   // slot 1
    uint256 balance;  // slot 2
}

// GOOD: 2 storage slots (40k gas to write all)
struct User {
    uint256 id;       // slot 0
    address wallet;   // slot 1 (20 bytes)
    uint96 balance;   // slot 1 (12 bytes) - packed!
}
```

### 13.4 Immutable and Constant

Use `constant` for compile-time values and `immutable` for constructor-set
values. Both avoid storage reads entirely.

```solidity
// BAD: SLOAD every access (~2,100 gas)
uint256 public fee = 100;

// GOOD: Embedded in bytecode (0 gas)
uint256 public constant FEE = 100;

// GOOD: Set in constructor, embedded (0 gas after deploy)
uint256 public immutable deployTime;
constructor() { deployTime = block.timestamp; }
```

### 13.5 Unchecked Arithmetic for Safe Operations

When overflow is mathematically impossible (e.g., loop counter increments),
`unchecked { i++; }` saves gas. But verify safety rigorously.

```solidity
// BAD: ~130 gas per iteration
for (uint256 i = 0; i < length; i++) { }

// GOOD: ~80 gas per iteration
for (uint256 i = 0; i < length; ) {
    // ...
    unchecked { ++i; }
}
```

### 13.6 Custom Errors Instead of Require Strings

```solidity
// BAD: ~50+ gas per character
require(balance >= amount, "Insufficient balance for withdrawal");

// GOOD: ~24 gas total
error InsufficientBalance();
if (balance < amount) revert InsufficientBalance();
```

### 13.7 Short-Circuit Conditions

```solidity
// BAD: Expensive check first
if (expensiveCheck() && simpleCheck) { }

// GOOD: Cheap check first
if (simpleCheck && expensiveCheck()) { }
```

### 13.8 Assembly for Hot Paths

Use inline assembly for gas-critical paths, but with caution:

```solidity
// Assembly transfer (saves ~100 gas)
function transfer(address to, uint256 amount) external {
    assembly {
        // Load sender balance
        mstore(0x00, caller())
        mstore(0x20, balances.slot)
        let senderSlot := keccak256(0x00, 0x40)
        let senderBalance := sload(senderSlot)

        // Check and update
        if lt(senderBalance, amount) { revert(0, 0) }
        sstore(senderSlot, sub(senderBalance, amount))

        // Update recipient
        mstore(0x00, to)
        let recipientSlot := keccak256(0x00, 0x40)
        sstore(recipientSlot, add(sload(recipientSlot), amount))
    }
}
```

**Audit note**: Assembly bypasses Solidity safety checks. Verify correctness manually.

---

## 14. Solidity-Specific Pitfalls

### 14.1 Floating Pragma (SWC-103)

Using `pragma solidity ^0.8.0` instead of a locked version. Lock to a
specific tested version in production.

### 14.2 Shadowed Variables (SWC-119)

Variables in derived contracts shadowing parent contract variables, causing
unexpected behavior.

### 14.3 Incorrect Inheritance Order

Solidity uses C3 linearization. Incorrect ordering of parent contracts
in the inheritance list can lead to unexpected function resolution.

### 14.4 Uninitialized Storage Pointers (SWC-109)

Local variables of reference type (`struct`, `array`) default to storage
pointer. If not explicitly initialized, they can point to unexpected
storage slots.

### 14.5 selfdestruct Risks

`selfdestruct` forces ETH to target address and removes contract code.
With EIP-6780, `selfdestruct` only sends ETH (doesn't destroy code)
unless called in the same transaction as creation.

### 14.6 Block Properties as Randomness (SWC-120)

`block.timestamp`, `block.number`, `blockhash` are manipulable by
miners/validators. Use Chainlink VRF or commit-reveal for randomness.

---

## 15. Governance Vulnerabilities

**Impact: Critical** | **Source: Compound, Beanstalk incident analyses**

### 15.1 Flash Loan Governance

Borrowing governance tokens to achieve quorum and pass malicious proposals
in a single block (Beanstalk, $182M, April 2022).

**Prevention**: Use checkpoint-based voting (ERC20Votes), enforce
voting delay, require token lock during voting.

### 15.2 Low Quorum Exploitation

Setting quorum too low allows minority token holders to pass proposals
when participation is low.

### 15.3 Timelock Bypass

Insufficient timelock duration or mechanisms to skip the timelock for
"emergency" actions that aren't truly gated.

### 15.4 Proposal Griefing

Spamming proposals to dilute attention or blocking legitimate proposals
through front-running.

---

## 16. Cross-Chain & Bridge Risks

**Impact: Critical** | **Source: Wormhole ($325M), Ronin ($625M), Nomad ($190M)**

### 16.1 Message Verification Failures

Insufficient validation of cross-chain messages. Accepting messages with
invalid or missing signatures from validators.

### 16.2 Replay Attacks Across Chains

Same message replayed on different chains or on the same chain after a
hard fork.

### 16.3 Validator Trust Assumptions

Bridges with small validator sets or single-signer models are vulnerable
to key compromise.

### 16.4 Token Wrapping Accounting Errors

Mismatch between locked tokens on source chain and minted tokens on
destination chain.

---

## 17. ERC-7702 Account Vulnerabilities

**EIP-7702** | **Impact: Critical to High** | **Source: Ethereum Prague/Electra upgrade**

ERC-7702 (active since the Prague hard fork) allows EOAs to temporarily set their code
to a smart contract implementation, enabling smart account features for regular wallets.
This introduces new attack vectors that did not exist for pure EOAs.

### 17.1 Delegation to Malicious Implementation

An ERC-7702 authorization allows any EOA to "become" a smart account by pointing to
an implementation contract. If users are socially engineered into signing a delegation
to an attacker-controlled contract, the attacker gains full control.

```solidity
// ERC-7702 authorization format (signed by EOA):
// { chain_id, address (implementation), nonce }

// ATTACK: Trick user into signing authorization for malicious contract
contract MaliciousImplementation {
    function execute(address target, bytes calldata data) external {
        // Once authorized, attacker calls this on behalf of the EOA
        // Has full access to EOA's ETH and approved tokens
        target.call(data);
    }
}
// If EOA signs authorization for this contract, attacker can drain it
```

**Detection**: Any protocol that accepts ERC-7702 authorizations as part of its flow
must validate the implementation address against an allowlist.

### 17.2 Signature Replay via ERC-7702

An authorization signed for one chain can be replayed on another if `chain_id = 0`
is used (intended for multi-chain deployments but dangerous).

```solidity
// VULNERABLE: accepting chain_id = 0 authorizations without restriction
function validateAuth(ERC7702Auth calldata auth) internal pure returns (bool) {
    // chain_id = 0 means "valid on all chains" — replay risk
    return auth.nonce == currentNonce[auth.signer];
}

// SECURE: require chain-specific authorization
function validateAuth(ERC7702Auth calldata auth) internal view returns (bool) {
    require(auth.chainId == block.chainid || auth.chainId == 0, "wrong chain");
    // If chain_id = 0, add additional binding (contract address, domain)
    require(auth.nonce == currentNonce[auth.signer], "invalid nonce");
    return true;
}
```

### 17.3 EOA Nonce Race Condition

ERC-7702 authorizations use the EOA's nonce. A new transaction from the EOA
increments the nonce and invalidates the delegation. Protocols relying on a cached
delegation may fail silently.

**Detection**: Systems that cache or pre-compute ERC-7702 delegations must handle
the case where the delegation is revoked between submission and execution.

### 17.4 Re-initialization of Delegated Code

If the implementation follows an upgradeable proxy pattern, a newly delegated EOA
may be able to call `initialize()` again, overwriting the account's configuration.

```solidity
// VULNERABLE implementation: no init guard
contract WalletImpl {
    address public owner;
    function initialize(address _owner) external {
        owner = _owner; // can be called by anyone after delegation
    }
}

// SECURE: use initializer guard or immutable owner set in constructor
contract WalletImpl {
    address public immutable OWNER;
    constructor(address owner) { OWNER = owner; }
    // No initialize() — ERC-7702 delegated EOA inherits immutable
}
```

### 17.5 Storage Collision with EOA State

EOA's that use ERC-7702 to delegate to an implementation share storage namespace.
If two different implementations are used sequentially, storage from the first
delegation persists and may be misinterpreted by the second.

**Detection**: Verify that any implementation used in ERC-7702 context uses
ERC-7201 namespaced storage to isolate state.

### Remediation

- Validate implementation addresses against an allowlist before accepting delegations
- Require chain-specific (`chain_id != 0`) authorizations for sensitive operations
- Use ERC-7201 namespaced storage in all ERC-7702 implementations
- Implement re-initialization guards
- Monitor for delegation changes in off-chain systems before relying on them

---

## 18. Uniswap V4 Hook Vulnerabilities

**Impact: Critical to High** | **Source: Uniswap V4 audit (Cantina, 2024)**

Uniswap V4 hooks are arbitrary contracts called before/after pool operations.
They execute within the PoolManager's context and can interact with delta accounting,
making them a significant new attack surface.

### 18.1 Unauthorized Token Drain via Hook

Hooks have `take()` access to the PoolManager's token balances. A hook that
does not properly restrict who can trigger pool operations can be drained.

```solidity
// VULNERABLE hook: allows anyone to extract tokens via a swap
contract VulnerableHook is BaseHook {
    function afterSwap(
        address sender,
        PoolKey calldata key,
        IPoolManager.SwapParams calldata params,
        BalanceDelta delta,
        bytes calldata hookData
    ) external override returns (bytes4, int128) {
        // hookData is attacker-controlled: specifies amount to extract
        uint256 amount = abi.decode(hookData, (uint256));
        poolManager.take(key.currency0, address(this), amount); // drain
        return (BaseHook.afterSwap.selector, 0);
    }
}
```

**Secure pattern**: Hooks must validate that operations are initiated by authorized
callers and that hookData is validated and bounded.

### 18.2 Hook Reentrancy via unlock()

V4's `unlock()` mechanism allows hooks to re-enter the PoolManager to settle
deltas. If a hook calls `unlock()` recursively, it can manipulate pool state
across multiple re-entries before settlement.

```solidity
// VULNERABLE: hook calls unlock() again inside afterSwap
function afterSwap(...) external override returns (bytes4, int128) {
    // This re-enters PoolManager's unlocked state
    poolManager.unlock(abi.encode("reenter")); // nested unlock
    return (BaseHook.afterSwap.selector, 0);
}

// SECURE: use a lock flag or restrict to single-level callbacks
bool private _inCallback;
function afterSwap(...) external override returns (bytes4, int128) {
    require(!_inCallback, "reentrant");
    _inCallback = true;
    // ... safe operations ...
    _inCallback = false;
    return (BaseHook.afterSwap.selector, 0);
}
```

### 18.3 Delta Accounting Manipulation

V4 uses net-delta accounting: hook callbacks can modify the effective swap amounts
by returning non-zero `int128` values. An incorrect or malicious hook can cause
users to receive fewer tokens than expected.

```solidity
// VULNERABLE: hook skims tokens from every swap by returning a non-zero delta
function afterSwap(...) external override returns (bytes4, int128) {
    int128 hookFee = int128(int256(uint256(-delta.amount1()) / 100)); // 1% skim
    poolManager.take(key.currency1, feeRecipient, uint128(hookFee));
    return (BaseHook.afterSwap.selector, hookFee); // reduces user's output
}
```

**Detection**: Verify hook return values and delta modifications are consistent
with the documented fee structure and within protocol-defined bounds.

### 18.4 Malicious Pool Initialization via Hook

Hooks receive `beforeInitialize` callbacks. A hook can front-run pool initialization
to set malicious initial state (e.g., extreme tick spacing, invalid initial price).

**Detection**: Pool key validation (fee tier, tick spacing, hooks address) must
be performed by the integrating protocol before using a pool.

### 18.5 Hook Permission Bit Misconfiguration

V4 encodes hook permissions in the hook address's leading bits. Permissions that
are set but not needed expand the attack surface unnecessarily.

```solidity
// Check hook permissions are minimal for the hook's function
// BEFORE_SWAP_FLAG = 0x0080  → can modify input amounts
// AFTER_SWAP_FLAG  = 0x0040  → can modify output amounts
// If a hook only needs AFTER_SWAP, it should NOT have BEFORE_SWAP

uint160 hookAddr = uint160(address(hook));
bool hasBeforeSwap = hookAddr & Hooks.BEFORE_SWAP_FLAG != 0;
bool hasAfterSwap  = hookAddr & Hooks.AFTER_SWAP_FLAG  != 0;
// Verify these match the hook's actual implementation
```

### Remediation

- Only integrate hooks from audited, immutable sources (no upgradeable hooks from untrusted parties)
- Validate pool key (including `hooks` address) against an allowlist before interaction
- Apply `nonReentrant` on all functions that call V4 pool operations
- Check hook permission bits match the hook's documented behavior
- See `defi-integrations.md` for full Uniswap V4 integration checklist

---

## 19. Transient Storage Specific Issues

**EIP-1153** | **Impact: High** | **Solidity >= 0.8.24 (Cancun upgrade)**

Transient storage (`tload`/`tstore`) provides per-transaction temporary storage that
costs less gas than regular storage and clears automatically. While useful for reentrancy
guards, it introduces new vulnerability patterns.

### 19.1 Incorrect Assumption of Persistence

Transient storage clears at the end of each transaction. Code that relies on it
persisting across transactions (like regular `SSTORE`) will silently fail.

```solidity
// VULNERABLE: storing user session data in transient storage
function startSession(address user) external {
    assembly { tstore(0, user) } // cleared after TX — useless for multi-TX sessions
}

function validateSession() external view returns (address) {
    address user;
    assembly { user := tload(0) }
    return user; // always returns address(0) in a new transaction
}

// SECURE: use regular storage for cross-transaction state
mapping(bytes32 => address) public activeSessions;
```

### 19.2 Reentrancy Guard Bypass via Delegatecall

When a contract with a transient-storage reentrancy guard is called via `delegatecall`,
both the caller and callee share the same transient storage context. A malicious
callee can read or modify the caller's reentrancy lock slot.

```solidity
// VULNERABLE: transient guard slot is predictable and shared via delegatecall
bytes32 constant GUARD_SLOT = keccak256("reentrancy.guard"); // known to attacker

// Attacker's contract: called via delegatecall from victim
contract Attacker {
    function attack() external {
        // Clears victim's reentrancy guard via shared transient storage
        assembly { tstore(0x1234, 0) } // if victim uses slot 0x1234
        // Now victim's guard is off — can reenter
    }
}

// SECURE: use a per-contract unique slot
bytes32 constant GUARD_SLOT =
    keccak256(abi.encode("reentrancy.guard", address(this))); // unique per deployment
```

### 19.3 Cross-Function Transient State Leak

Multiple functions in a contract that use the same transient storage slot within
one transaction can inadvertently share state, causing unexpected behavior.

```solidity
// VULNERABLE: two hooks share slot 0
function hookA() external {
    assembly { tstore(0, 1) } // set flag
    externalCall();            // externalCall triggers hookB in same TX
}

function hookB() external {
    uint256 flag;
    assembly { flag := tload(0) } // reads hookA's flag — unintended!
    if (flag == 1) { /* wrong branch taken */ }
}

// SECURE: use distinct named slots per function
bytes32 constant HOOK_A_SLOT = keccak256("hook.a.flag");
bytes32 constant HOOK_B_SLOT = keccak256("hook.b.flag");
```

### 19.4 Flash Loan Callback Context Loss

If a flash loan callback uses transient storage to pass context between the initiator
and the callback, any intermediate external call that modifies the same slot can
corrupt the context.

**Detection**: Audit all transient storage slot names for potential collisions with
third-party contracts in composable DeFi flows.

### 19.5 Incorrect Transient Guard in Proxy Context

When using ERC-7201 namespaced storage alongside transient storage, transient slots
are not namespaced — they are raw numbers in transient storage space. Proxy contracts
and implementation contracts share the same transient storage if called in the same
transaction context.

### Remediation

- Use `keccak256`-derived slots for all transient storage to avoid collisions
- Never rely on transient storage for cross-transaction state
- In proxy patterns, namespace transient slots uniquely per contract identity
- Document all transient slot assignments alongside regular storage layout
- Test transient storage behavior under reentrancy scenarios explicitly

---

## Quick Reference: Severity Mapping

| Vulnerability | Typical Severity | Exploitability |
|---|---|---|
| Reentrancy (funds at risk) | Critical | High |
| Missing access control | Critical | High |
| Uninitialized proxy | Critical | High |
| Oracle manipulation | Critical | High (with flash loans) |
| Storage collision | Critical | Medium |
| Unchecked delegatecall | Critical | High |
| ERC-7702 malicious delegation | Critical | Medium (social eng.) |
| Uniswap V4 hook drain | Critical | High |
| Integer overflow (pre-0.8) | High | High |
| Signature replay | High | Medium |
| Unbounded loops DoS | High | Medium |
| Transient storage collision | High | Medium |
| ERC-7702 re-initialization | High | Medium |
| Front-running exposure | Medium-High | High (MEV bots) |
| Fee-on-transfer tokens | Medium | Medium |
| Transient storage persistence | Medium | Low |
| Floating pragma | Low | Low |
| Missing events | Informational | N/A |
| Gas optimizations | Informational | N/A |
